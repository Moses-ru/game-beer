<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, user-scalable=no" />
    <title>Telegram Tetris</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script crossorigin src="https://unpkg.com/framer-motion/dist/framer-motion.umd.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      body {
        margin: 0;
        background: #111827;
        color: white;
        font-family: sans-serif;
        touch-action: manipulation;
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script type="text/javascript">
      const { useState, useEffect, useRef } = React;
      const { motion } = window["framer-motion"];

      const colors = ["#F87171", "#FBBF24", "#34D399", "#60A5FA", "#A78BFA", "#F472B6"];
      const ROWS = 20;
      const COLS = 10;

      const getRandomColor = () => colors[Math.floor(Math.random() * colors.length)];
      const initialBlock = () => ({ x: Math.floor(COLS / 2), y: 0, color: getRandomColor() });

      function StackGame() {
        const [blocks, setBlocks] = useState([]);
        const [current, setCurrent] = useState(initialBlock);
        const [score, setScore] = useState(0);
        const [isGameOver, setIsGameOver] = useState(false);
        const intervalRef = useRef(null);
        const touchStartX = useRef(null);
        const touchStartY = useRef(null);
        const touchStartTime = useRef(null);
        const holdRef = useRef(false);

        const reset = () => {
          setBlocks([]);
          setScore(0);
          setIsGameOver(false);
          setCurrent(initialBlock());
        };

        const sendScore = (score) => {
          const scoreData = JSON.stringify({ score });
          if (window.parent) window.parent.postMessage(scoreData, "*");
          if (window.Telegram?.WebApp) window.Telegram.WebApp.sendData(scoreData);
        };

        const handlePlace = () => {
          const newBlocks = [...blocks, current];
          setBlocks(newBlocks);
          const newScore = score + 1;
          setScore(newScore);
          sendScore(newScore);
          if (newBlocks.some((b) => b.y === 0)) {
            setIsGameOver(true);
            clearInterval(intervalRef.current);
          } else {
            setCurrent(initialBlock());
          }
        };

        const moveDown = () => {
          setCurrent((prev) => {
            if (prev.y < ROWS - 1 && !blocks.some((b) => b.x === prev.x && b.y === prev.y + 1)) {
              return { ...prev, y: prev.y + 1 };
            } else {
              handlePlace();
              return prev;
            }
          });
        };

        useEffect(() => {
          if (!isGameOver) {
            intervalRef.current = setInterval(() => {
              if (!holdRef.current) moveDown();
            }, 500);
          }
          return () => clearInterval(intervalRef.current);
        }, [blocks, isGameOver]);

        const handleTouchStart = (e) => {
          const touch = e.touches[0];
          touchStartX.current = touch.clientX;
          touchStartY.current = touch.clientY;
          touchStartTime.current = Date.now();
          holdRef.current = true;
        };

        const handleTouchMove = (e) => {
          const touch = e.touches[0];
          const dx = touch.clientX - touchStartX.current;
          const dy = touch.clientY - touchStartY.current;

          if (Math.abs(dx) > 30 && Math.abs(dx) > Math.abs(dy)) {
            setCurrent((prev) => ({
              ...prev,
              x: Math.max(0, Math.min(COLS - 1, prev.x + (dx > 0 ? 1 : -1))),
            }));
            touchStartX.current = touch.clientX;
          } else if (dy > 30) {
            moveDown();
            touchStartY.current = touch.clientY;
          }
        };

        const handleTouchEnd = () => {
          const duration = Date.now() - touchStartTime.current;
          if (duration < 200) {
            // tap = rotate
          } else {
            const drop = () => {
              setCurrent((prev) => {
                if (
                  prev.y < ROWS - 1 &&
                  !blocks.some((b) => b.x === prev.x && b.y === prev.y + 1)
                ) {
                  return { ...prev, y: prev.y + 1 };
                } else {
                  handlePlace();
                  return prev;
                }
              });
            };
            const dropInterval = setInterval(() => {
              drop();
            }, 30);
          }
          holdRef.current = false;
        };

        return React.createElement("div", {
          className: "flex flex-col items-center justify-center w-full h-screen select-none",
          children: [
            React.createElement("div", {
              className: "text-2xl font-bold mb-2",
              children: `Score: ${score}`,
            }),
            React.createElement("div", {
              className: "relative bg-gray-900",
              style: {
                width: COLS * 20,
                height: ROWS * 20,
                touchAction: "none",
              },
              onTouchStart: handleTouchStart,
              onTouchMove: handleTouchMove,
              onTouchEnd: handleTouchEnd,
              children: [
                ...blocks.map((b, i) =>
                  React.createElement(motion.div, {
                    key: i,
                    className: "absolute w-5 h-5",
                    style: {
                      left: b.x * 20,
                      top: b.y * 20,
                      backgroundColor: b.color,
                    },
                    initial: { scale: 0 },
                    animate: { scale: 1 },
                  })
                ),
                !isGameOver &&
                  React.createElement(motion.div, {
                    className: "absolute w-5 h-5",
                    style: {
                      left: current.x * 20,
                      top: current.y * 20,
                      backgroundColor: current.color,
                    },
                    initial: { scale: 0 },
                    animate: { scale: 1 },
                  }),
                isGameOver &&
                  React.createElement("div", {
                    className:
                      "absolute inset-0 bg-black bg-opacity-80 flex items-center justify-center text-white text-xl font-bold",
                    children: "Game Over",
                  }),
              ],
            }),
            isGameOver &&
              React.createElement("button", {
                onClick: reset,
                className: "mt-4 px-4 py-2 bg-green-500 text-white rounded-xl shadow-lg",
                children: "Restart",
              }),
          ],
        });
      }

      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(React.createElement(StackGame));
    </script>
  </body>
</html>
